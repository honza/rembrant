// Generated by CoffeeScript 1.3.3
(function() {
  var CDN, async, cloudfiles, createQueue, crypto, findit, fs, getBuildFiles, getSha, knox, path, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('underscore');

  async = require('async');

  crypto = require('crypto');

  fs = require('fs');

  path = require('path');

  cloudfiles = require('cloudfiles');

  knox = require('knox');

  findit = require('findit');

  CDN = (function() {

    function CDN(type, cwd, name, secret, bucket) {
      this.type = type;
      this.cwd = cwd;
      this.name = name;
      this.secret = secret;
      this.bucket = bucket;
      this.uploadFile = __bind(this.uploadFile, this);

      switch (this.type) {
        case 'cloudfiles':
          this.client = cloudfiles.createClient({
            auth: {
              username: this.name,
              apiKey: this.secret
            }
          });
          break;
        case 'aws':
          this.client = knox.createClient({
            key: this.name,
            secret: this.secret,
            bucket: this.bucket
          });
          break;
        default:
          console.log("Not implemented");
      }
    }

    CDN.prototype.uploadFile = function(filename, callback) {
      var options;
      console.log("Uploading " + filename);
      if (this.bucket === 'undefined') {
        throw "Undefined bucket";
      }
      options = {
        remote: path.basename(filename),
        local: filename
      };
      return this.client.putFile(filename, path.basename(filename), function(err, uploaded) {
        return callback();
      });
    };

    CDN.prototype.uploadFiles = function(files, done) {
      var client, cwd, file, queue, _i, _len, _results,
        _this = this;
      client = this.client;
      cwd = this.cwd;
      queue = async.queue(function(task, callback) {
        return _this.uploadFile(task.filename, callback);
      }, 10);
      queue.drain = function() {
        console.log('all files uploaded');
        return done();
      };
      _results = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        _results.push(queue.push({
          filename: file
        }));
      }
      return _results;
    };

    return CDN;

  })();

  createQueue = function(finished) {
    var data, queue;
    data = {};
    queue = async.queue(function(task, callback) {
      return getSha(task.filename, function(hash) {
        data[task.filename] = hash;
        return callback();
      });
    }, 5);
    queue.drain = function() {
      console.log('all shas done');
      return finished(data);
    };
    return queue;
  };

  getSha = function(filename, callback) {
    var hash, stream;
    hash = crypto.createHash('sha1');
    stream = fs.ReadStream(filename);
    stream.on('data', function(d) {
      return hash.update(d);
    });
    return stream.on('end', function() {
      return callback(hash.digest('hex'));
    });
  };

  getBuildFiles = function(library, cwd) {
    var build, files;
    build = "" + cwd + "/build";
    files = findit.sync(build);
    return _.reject(files, function(f) {
      return fs.statSync(f).isDirectory();
    });
  };

  exports.deploy = function(library, cwd) {
    var bucket, cdn, difference, f, files, key, map, q, secret, type, _i, _len, _ref, _results;
    _ref = library.deploy, key = _ref.key, secret = _ref.secret, bucket = _ref.bucket, type = _ref.type;
    if (!secret) {
      console.log('Missing secret');
      return;
    }
    if (!key) {
      console.log('Missing key');
      return;
    }
    if (!bucket) {
      console.log('Missing bucket');
      return;
    }
    if (!type) {
      console.log('Missing type');
      return;
    }
    cdn = new CDN('aws', cwd, key, secret, bucket);
    if (fs.existsSync("s3map.json")) {
      map = JSON.parse(fs.readFileSync("s3map.json", "utf-8"));
    } else {
      map = {};
    }
    files = getBuildFiles(library, cwd);
    difference = _.difference(files, _.keys(map));
    q = createQueue(function(data) {
      var fn, hash;
      for (fn in map) {
        hash = map[fn];
        if (data[fn] !== hash) {
          difference.push(fn);
        }
      }
      return cdn.uploadFiles(difference, function() {
        var f, _i, _len, _ref1;
        console.log('done all');
        _ref1 = _.keys(data);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          f = _ref1[_i];
          map[f] = data[f];
        }
        return fs.writeFileSync("s3map.json", JSON.stringify(map, null, 4), "utf-8");
      });
    });
    _results = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      f = files[_i];
      _results.push(q.push({
        filename: f
      }));
    }
    return _results;
  };

}).call(this);
